################
# Introduction
################

# The problem is the following:
- we want to launch a task
- get the result
- use this result to launch another task

example:
- get user id
- get user information from DB using id
- send the mail to the users

# generic template
ExecutorService service = Executors.newSingle....();
Runnable task = () -> {};
Future future = service.submit(task);

// do something

Object result = future.get(); // block
or,
future.cancel();

=> target is to make it non-blocking


# asynchronous and concurrent are different notions
- what we need is:
  - being able to trigger a task on the completion of another one
  - being able to specify in which thread a task is executed

- one solution is fire an event and have a listener to get notified and do some action
- however, this is still blocking and synchronous
- thus, events are not the right tools - lets check messages
- a message is sent to the broker
- this will trigger the subscribers of this kind of message
- however, even message driven design is synchronous

- event vs message:
- an event is a signal
- a message is a piece of data that recipients will get and react upon based on the message


#####################################################
# Setting up an async operation with CompletionStage
#####################################################
- Define a task
- how to launch a task in another thread?
  - Runnable (no return)
  - Callable (return a value and throws exception)

- Runnable runnable = () -> {....};
- Callable<User> callable = () -> connection.readUser(1L);

- if want to execute the task in the same thread (calling thread):
runnable.run(); // instead of using start()
callable.call(); // instead of submitting to executor service

- if want to execute the task in another thread:
new Thread(runnable).start();
or
Thread thread = new Thread();
thread.start(runnable);

=> the above pattern should not be used anymore, instead use executor service
ExecutorService service = Executors.newSingleThreadExecutor();
Future<?> future = service.submit(runnable);
or
Future<User> future = service.submit(callable);


----------

## From Future to CompletableFuture
- CompletableFuture is almost same as Future but has more methods
- important methods:
runAsync(runnable)
supplyAsync(supplier)

- example (Runnable):
instead of using Future object,
  Future<?> future = service.submit(runnable);
use,
  CompletableFuture<Void> compFut = CompletableFuture.runAsync(runnable);

- CompletableFuture does NOT work with Callables but only with Suppliers
- example (Supplier):
Supplier<User> supplier = () -> connection.readUser(1L);
...
// service.submit(supplier); // this will NOT compile
CompletableFuture<User> compFut = CompletableFuture.supplyAsync(supplier);

- can convert any Callable to Supplier but ensure that supplier can NOT throw any checked exceptions
- by default, the async tasks are run in the common fork/join pool
- however, can also pass executor service as an argument
- example:
Future<?> future = service.submit(runnable);
CompletableFuture<Void> compFut = CompletableFuture.runAsync(runnable, service);
or,
CompletableFuture<User> compFut = CompletableFuture.supplyAsync(supplier, service);


----------

## Closer look at CompletableFuture
- CompletableFuture is a class that implements:
Future
CompletionStage

- CompletionStage adds methods to chain tasks
- CompletableFuture add more methods

- a task has a state:
running
completed normally
completed exceptionally

- 5 methods in Future
T get();
T get(long timeOut, TimeUnit unit);
void cancel();
boolean isDone();
boolean isCancelled();

# more methods in CompletableFuture
- get the results in a different way
T join(); // may throw an unchecked exception
T getNow(T valueIfAbsent);

- force the returned value
boolean complete(V value);
void obtrudeValue(V value);

- force an exception
boolean completeExceptionally(Throwable t);
void obtrudeException(Throwable t);


----------

## force the returned value

# boolean complete(V value)
checks if the task is done
- if its done: then does nothing
- if its not done, then it completes it and sets the returned value to given value

# void obtrudeValue(V value)
checks if the task is done
- if its done: then forces the returned value to given value => this is the difference with complete(value) method
- if its not done, then it completes it and sets the returned value to given value
- this function should be used only in error recovery operations


----------

## force an exception

# boolean completeExceptionally(Throwable t)
- forces the completion if the task is NOT done

# void obtrudeException(Throwable t)
- forces the completion even if the task is done



#############
# Demo code
#############

## FirstCompletableFutures.java

- suppose in my main(): I just write this code

Runnable task = () -> {
      System.out.println("I am running asynchronously in the thread " + Thread.currentThread().getName());
    };

CompletableFuture.runAsync(task);

- nothing is printed on output
=> CompletableFuture uses default fork/join pool and the async thread is daemon
   thus, the main thread dies and exits the program without printing anything
   just adding Thread.sleep(100) after runAsync() call will print the message above

- now suppose I create a ExecutorService and pass that to runAsync()
CompletableFuture.runAsync(task, service);

- here the program will not terminate as the main thread will exit - however executor service is still running its thread from the pool
as it is non-daemon => need to explicitly call service.shutdown()

- also no need to use Thread.sleep() as executor will complete the submitted task before shutdown completely

--------------------

## CompletableFutureWithSupplier.java
- similar to Runnable above, if pass a supplier to supplyAsync() - it will no do anything when main() thread exits
Supplier<String> supplier = () -> Thread.currentThread().getName();
CompletableFuture.supplyAsync(supplier);

- thus, can call join() for main() to block first
CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(supplier);
String string = completableFuture.join();
System.out.println("Result = " + string);

- can add sleep() in Supplier and use complete() or obtrudeValue() to force the return value


--------------------

## SimpleCompletableFuture
- how to complete() a completableFuture

--------------------


#####################################################
# Triggering a Task on the Completion of other tasks
#####################################################
- use case:
have a list of primary keys - user ids (supplier)
fetch all users from database for all the user ids (mapping)
store them in a List<User> (reduce)

- First task: provide the list of the primary keys
CompletableFuture<List<Long>> cf1 = CompletableFuture.supplyAsync(() -> List.of(1L, 2L, 3L));

- Chain a subsequent task on the completion of the first task using thenApply()
CompletableFuture<List<Long>> cf2 = CompletableFuture.supplyAsync(() -> List.of(1L, 2L, 3L))
                 .thenApply(list -> readUsers(list));

- can define mapper which maps List<Long> (argument) to List<User> (return)
Function<List<Long>, List<User>> mapper = list -> readUsers(list);

- Suppose want to log a message when the list is available
cf2.thenRun(() -> logger.info("The list of users has been read"));

OR, use a consumer:
cf2.thenAccept(users -> logger.info(users.size() + " users have been read"));

- CF methods:
Runnable => thenRun()
Consumer => thenAccept()
Function => thenApply()


#######################
# Single Task Chaining
#######################
- Suppose need to update a DB with a long running process, so can chain a runnable task
CompletableFuture<Void> cf = CompletableFuture.runAsync(() -> updateDB())
                                              .thenRun(() -> logger.info("Update done!"));

- if use thenAccept(), then the value passed will be null - not recommended
.thenAccept(value -> ...)

- instead use supplier if want to use thenAccept() or thenRun()
CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> List.of(1L, 2L, 3L))
                                              .thenRun(() -> logger.info("..."));

- So the first task can be:
supplier: supplyAsync()
runnable: runAsync()

- and the next task can be:
runnable: thenRun()
consumer: thenAccept()
function: thenApply()


###############################
# Composing CompletableFuture
###############################
- use case:
Suppose first task fetches a list of User IDs from a remote service
Second task fetches user object from a DB
Both tasks are long running processes and should be run async

- Snippet:
Supplier<List<Long>> userIdsSupplier = () -> remoteService(); // returns the user IDs
Function<List<Long>, List<User>> usersFromIds = ids -> fetchFromDB(ids); // returns the user objects

CompletableFuture.supplyAsync(userIdsSupplier)
                 .thenApply(usersFromIds);

- modify the snippet code to fetch users from DB async
Function<List<Long>, CompletableFuture<List<User>>> usersFromIds = ids -> fetchFromDB(ids); // returns the user objects

CompletableFuture.supplyAsync(userIdsSupplier)
                 .thenCompose(usersFromIds);

- thenCompose() is more like flatMap() for streams


################################
# Triggering more than one task
################################
- use case:
Get IDs -> Read Users + Log IDs -> Send Email -> Write Report + Log Emails

OR,
Get IDs -> Read Users + Get Emails -> Send Email
# Send Email is launched if Read Users and Get Emails are done

OR,
Get IDs -> Read Users + Read Users -> Send Email
# Send Email is launched if any of Read Users is done

- When both tasks complete, we can
execute a Runnable
execute a BiConsumer
execute a BiFunction

- the 2 combined completable futures can return object of different types
CompletableFuture<Long> cf1 = ...;
CompletableFuture<User> cf2 = ...;

CompletableFuture<Void> cf3 = cf1.thenAcceptBoth(cf2, (id, name) -> logger.info(...)); // BiConsumer

OR,
CompletableFuture<List<User>> cf3 = cf1.thenCombine(cf2, (id, user) -> query(...)); // BiFunction















